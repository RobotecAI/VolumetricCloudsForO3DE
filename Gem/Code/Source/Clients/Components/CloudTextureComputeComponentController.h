/*
* Copyright (c) Galib Arrieta (aka lumbermixalot@github, aka galibzon@github).
*
* SPDX-License-Identifier: Apache-2.0 OR MIT
*
*/

#pragma once

#include <AzCore/Component/Component.h>
#include <AzCore/Component/TransformBus.h>

#include <VolumetricClouds/CloudTextureProviderBus.h>
#include <Renderer/CloudTexturePresentationData.h>
#include <Renderer/CloudTexturesComputeFeatureProcessor.h>


namespace VolumetricClouds
{
    class CloudTexturesDebugViewerFeatureProcessor;

    //! Common configuration for CloudTextureComputeComponent that can be used to create
    //! CloudTextureComputeComponents dynamically and can be shared with EditorCloudTextureComputeComponent.
    class CloudTextureComputeComponentConfig final
        : public AZ::ComponentConfig
    {
    public:
        AZ_RTTI(CloudTextureComputeComponentConfig, "{8BFFCCD3-EC7B-43E2-94FC-C62CB8FCDE52}", AZ::ComponentConfig);
        AZ_CLASS_ALLOCATOR(CloudTextureComputeComponentConfig, AZ::SystemAllocator);
    
        static void Reflect(AZ::ReflectContext* context);
    
        // How to Debug render the Texture3D in the scene.
        CloudTexturePresentationData m_presentationData;
        // How to compute and geneate the Texture3D with Perlin-Worley noise.
        CloudTextureComputeData m_computeData;

    };
    
    class CloudTextureComputeComponentController final
        : private AZ::TransformNotificationBus::Handler
        , public CloudTextureProviderRequestBus::Handler
    {
    public:
        AZ_CLASS_ALLOCATOR(CloudTextureComputeComponentController, AZ::SystemAllocator);
        AZ_RTTI(CloudTextureComputeComponentController, "{0D873FF0-685A-41B3-A06D-A7EFB8043223}");

        static void Reflect(AZ::ReflectContext* context);
        static void GetProvidedServices(AZ::ComponentDescriptor::DependencyArrayType& provided);
        static void GetIncompatibleServices(AZ::ComponentDescriptor::DependencyArrayType& incompatible);
    
        CloudTextureComputeComponentController() = default;
        CloudTextureComputeComponentController(const CloudTextureComputeComponentConfig& config);
    
        void Activate(AZ::EntityId entityId);
        void Deactivate();
        void SetConfiguration(const CloudTextureComputeComponentConfig& config);
        const CloudTextureComputeComponentConfig& GetConfiguration() const;

        // Forces cloud texture regeneration by executing the compute pipeline
        // and optionally doing texture readback to CPU.
        // @param readbackHandler If not null, the compute pipeline will queue attachment readback
        //        and when volume texture has been read back to CPU there will be several notifications
        //        signaled on this handler, one for each mip level.
        // REMARK: Typically only called by the EditorCloudTextureComputeComponent when the user clicks
        //         on the "Save To Disk" button.
        void ForceCloudTextureRegeneration(CloudTexturesComputeFeatureProcessor::ReadbackEvent::Handler* readbackHandler = nullptr);

        /////////////////////////////////////////////////////////
        // CloudTextureProviderRequestBus::Handler overrides ....
        AZ::Data::Instance<AZ::RPI::Image> GetCloudTextureImage() override;
        /////////////////////////////////////////////////////////

    private:
        AZ_DISABLE_COPY(CloudTextureComputeComponentController);
        static constexpr char LogName[] = "CloudTextureComputeComponentController";

        //! AZ::TransformNotificationBus::Handler
        void OnTransformChanged(const AZ::Transform& /*local*/, const AZ::Transform& /*world*/) override;

        CloudTexturesComputeFeatureProcessor* GetComputeFeatureProcessor();
        CloudTexturesDebugViewerFeatureProcessor* GetDebugViewerFeatureProcessor();

        friend class EditorCloudTextureComputeComponent;
        void OnConfigurationChanged();
    
        AZ::EntityId m_entityId;
        CloudTextureComputeComponentConfig m_configuration;
        CloudTextureComputeComponentConfig m_prevConfiguration;

        // We don't own this. We just cache these references.
        CloudTexturesComputeFeatureProcessor* m_computeFeatureProcessor = nullptr;
        CloudTexturesDebugViewerFeatureProcessor* m_debugViewerFeatureProcessor = nullptr;

        CloudTexturesComputeFeatureProcessor::TextureReadyEvent::Handler m_textureReadyEventHandler;

        // Generated by the CloudTexturesComputeFeatureProcessor and we keep a reference
        // to it.
        AZ::Data::Instance<AZ::RPI::Image> m_cloudTextureImage;
    };

} // namespace VolumetricClouds
